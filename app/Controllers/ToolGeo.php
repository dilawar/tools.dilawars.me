<?php

namespace App\Controllers;

use phpGPX\Helpers\GeoHelper;
use phpGPX\Models\GpxFile;
use phpGPX\Models\Point;
use phpGPX\Models\Segment;
use phpGPX\Models\Track;

class ToolGeo extends BaseController
{
    public function viewMapRoute(): string
    {
        return $this->loadView();
    }

    public function handleMapRoute(): string 
    {
        log_message('info', "Handling map route...");

        $post = (array) $this->request->getPost();
        log_message('debug', "post data " . json_encode($post));

        $rules = [
            'geojson' => [
                'uploaded[geojson]',
            ],
            'start_time' => 'valid_date',
            'end_time' => 'valid_date',
        ];
        if (! $this->validateData($post, $rules)) {
            return $this->loadView();
        }

        $data = (array) $this->request->getPost();
        // log_message('debug', "Got data  " . json_encode($data));

        $file = $this->request->getFile('geojson');
        assert(! is_null($file));
        $fileOnDisk = $file->getTempName();
        $content = json_decode((string) file_get_contents($fileOnDisk), true);

        $coords = $content['geometry']['coordinates'];
        $result = $this->createGpx($coords, startTime: $post['start_time'], endTime: $post['end_time']);
        log_message('debug', "Result is " . $result);

        $data = [
            'result' => [
                'filename' => changeExtension($file->getClientName(), '.gpx'),
                'xml' => $result,
            ],
        ];
        return view('tools/map_route', $data);
    }

    /**
     * @param array<array{float, float, ?float}> $points
     * @param array<string, string> $params
     */
    private function createGpx(array $points, string $startTime, string $endTime, array $params = []): string 
    {
        $gpx = new GpxFile();

        $track = new Track();
        $track->name = "Route generated by MaxFlow tools";
        $track->type = $params['type'] ?? 'RUN';

        $startTime = strtotime($startTime);
        $duration = strtotime($endTime) - $startTime;

        $segment = new Segment();
        foreach($points as $p) {
            $point = new Point(Point::TRACKPOINT);
            $point->latitude = $p[0];
            $point->longitude = $p[1];
            $point->elevation = $p[2] ?? 0;

            $segment->points[] = $point;
        }

        // Length of the segment.
        $lastPoint = end($segment->points);
        assert($lastPoint != false);
        $firstPoint = $segment->points[0];

        $segmentLength = GeoHelper::getRealDistance($firstPoint, $lastPoint);
        $speed = floatval($segmentLength) / floatval($duration);
        log_message('info', "Segment length $segmentLength m for duration $duration sec, speed=$speed m/s");

        // add timestamp.
        foreach($segment->points as &$point) {
            $distance = GeoHelper::getRawDistance($firstPoint, $point);
            $dtInSec = $speed * $distance;
            $time = new \DateTime()->setTimestamp(intval($startTime + $dtInSec));
            $point->time = $time;
        }

        $track->segments[] = $segment;
        $track->recalculateStats();
        $gpx->tracks[] = $track;

        return (string) $gpx->toXML()->saveXML();
    }

    /**
     * @param array<string, mixed> $extra
     */
    private function loadView(array $extra = []): string 
    {
        $post = (array) $this->request->getPost();
        $data = [...$post, ...$extra];
        return view('tools/map_route', $data);
    }
}
