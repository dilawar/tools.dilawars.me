<?php

/*
 * This file is part of the proprietary project.
 *
 * This file and its contents are confidential and protected by copyright law.
 * Unauthorized copying, distribution, or disclosure of this content
 * is strictly prohibited without prior written consent from the author or
 * copyright owner.
 *
 * For the full copyright and license information, please view the LICENSE.md
 * file that was distributed with this source code.
 */

namespace App\Controllers;

use CodeIgniter\HTTP\DownloadResponse;
use phpGPX\Helpers\GeoHelper;
use phpGPX\Models\GpxFile;
use phpGPX\Models\Point;
use phpGPX\Models\Segment;
use phpGPX\Models\Track;

class ToolGeo extends BaseController
{
    public function viewMapRoute(): string
    {
        return $this->loadView();
    }

    /**
     * Handle request from map route.
     */
    public function handleMapRoute(): string|DownloadResponse
    {
        log_message('info', 'Handling map route...');

        $post = (array) $this->request->getPost();
        log_message('debug', 'post data '.json_encode($post));

        $rules = [
            'geojson' => 'required',
            'start_time' => 'valid_date',
            'end_time' => 'valid_date',
        ];

        if (! $this->validateData($post, $rules)) {
            return $this->loadView();
        }

        $content = json_decode((string) $post['geojson'], true);
        $coords = $content['geometry']['coordinates'];

        $gpx = $this->createGpx($coords, startTime: $post['start_time'], endTime: $post['end_time']);
        log_message('debug', 'Result is '.$gpx);

        $date = date('Y-m-d');
        $filename = sprintf('maxflow-%s.gpx', $date);

        return $this->response->download($filename, $gpx);
    }

    /**
     * @param array<array{float, float, ?float}> $points
     * @param array<string, string>              $params
     */
    private function createGpx(array $points, string $startTime, string $endTime, array $params = []): string
    {
        $gpx = new GpxFile();

        $track = new Track();
        $track->name = 'Route generated by MaxFlow tools';
        $track->type = $params['type'] ?? 'RUN';

        $startTime = strtotime($startTime);
        $duration = strtotime($endTime) - $startTime;

        $segment = new Segment();
        foreach ($points as $p) {
            $point = new Point(Point::TRACKPOINT);
            $point->latitude = $p[0];
            $point->longitude = $p[1];
            $point->elevation = $p[2] ?? 0;

            $segment->points[] = $point;
        }

        // Length of the segment.
        $lastPoint = end($segment->points);
        assert(false != $lastPoint);
        $firstPoint = $segment->points[0];

        $segmentLength = GeoHelper::getRealDistance($firstPoint, $lastPoint);
        $speed = floatval($segmentLength) / floatval($duration);
        log_message('info', sprintf('Segment length %s m for duration %d sec, speed=%s m/s', $segmentLength, $duration, $speed));

        // add timestamp.
        foreach ($segment->points as &$point) {
            $distance = GeoHelper::getRawDistance($firstPoint, $point);
            $dtInSec = $speed * $distance;
            $time = new \DateTime()->setTimestamp(intval($startTime + $dtInSec));
            $point->time = $time;
        }

        $track->segments[] = $segment;
        $track->recalculateStats();
        $gpx->tracks[] = $track;

        return (string) $gpx->toXML()->saveXML();
    }

    /**
     * @param array<string, mixed> $extra
     */
    private function loadView(array $extra = []): string
    {
        $post = (array) $this->request->getPost();
        $data = [...$post, ...$extra];

        return view('tools/map_route', $data);
    }
}
